var documenterSearchIndex = {"docs":
[{"location":"models/brusselator/#Brusselator","page":"Brusselator","title":"Brusselator","text":"","category":"section"},{"location":"models/brusselator/#Model","page":"Brusselator","title":"Model","text":"The Brusselator is a two ODEs theoretical model for autocatalytic reactions, where x and y are chemical concentrations:\n\nusing ReachabilityAnalysis\n\nconst A = 1.0\nconst B = 1.5\nconst B1 = B + 1\n\n@taylorize function brusselator!(du, u, p, t)\n    x, y = u\n    x² = x * x\n    aux = x² * y\n    du[1] = A + aux - B1 * x\n    du[2] = B * x - aux\n    return du\nend\n\nfunction model(X0)\n    S = @system(x' = brusselator!(x), dim:2)\n    return IVP(S, X0)\nend","category":"section"},{"location":"models/brusselator/#Reachability-settings","page":"Brusselator","title":"Reachability settings","text":"","category":"section"},{"location":"models/brusselator/#Results","page":"Brusselator","title":"Results","text":"","category":"section"},{"location":"models/brusselator/#References","page":"Brusselator","title":"References","text":"","category":"section"},{"location":"models/jet_engine/","page":"Jet Engine","title":"Jet Engine","text":"module jet_engine\nusing ReachabilityAnalysis\n@taylorize function jet_engine!(dx, x, params, t)\n    dx[1] = -x[2] - 1.5 * x[1]^2 - 0.5 * x[1]^3 - 0.5\n    dx[2] = 3 * x[1] - x[2]\n    return dx\nend\n\nfunction model(X0)\n    S = @system(x' = jet_engine!(x), dim:2)\n    return IVP(S, X0)\nend\nend # module","category":"section"},{"location":"models/pde/","page":"PDE","title":"PDE","text":"PDE\n\nusing ReachabilityModels, MAT, ReachabilityBase.CurrentPath\n\nfile = matopen(@current_path(\"pde\", \"pde.mat\"))\n\n# system matrix\nA = float(read(file, \"A\"))  # the matrix has Int entries\n\n# input matrix\nB = read(file, \"B\")\n\n# state domain\nX = Universe(84)\n\n# input domain\nU = BallInf([0.75], 0.25)\n\nfunction model(X0)\n    S = @system(x' = Ax + Bu, x ∈ X, u ∈ U)\n    return IVP(S, X0)\nend\n\nReachability settings\n\nResults","category":"section"},{"location":"models/lorenz/","page":"Lorenz","title":"Lorenz","text":"module lorenz\nusing ReachabilityAnalysis\n@taylorize function lorenz!(dx, x, params, t)\n    σ, β, ρ = 10.0, 8.0 / 3.0, 28.0\n    dx[1] = σ * (x[2] - x[1])\n    dx[2] = x[1] * (ρ - x[3]) - x[2]\n    dx[3] = x[1] * x[2] - β * x[3]\n    return dx\nend\n\nfunction model(X0)\n    S = @system(x' = lorenz!(x), dim:3)\n    return IVP(S, X0)\nend\nend # module","category":"section"},{"location":"models/coupled_vanderpol/#Coupled-Van-der-Pol-oscillator","page":"Coupled VanDerPol","title":"Coupled Van der Pol oscillator","text":"","category":"section"},{"location":"models/coupled_vanderpol/#Model","page":"Coupled VanDerPol","title":"Model","text":"using ReachabilityAnalysis\n\n@taylorize function coupled_vanderpol!(du, u, p, t)\n    du[1] = u[2]\n    du[2] = (1.0 - u[1]^2) * u[2] - u[1] + (u[3] - u[1])\n    du[3] = u[4]\n    du[4] = (1.0 - u[3]^2) * u[4] - u[3] + (u[1] - u[3])\n    return du\nend\n\nfunction model(X0)\n    S = @system(x' = coupled_vanderpol!(x), dim:4)\n    return IVP(S, X0)\nend","category":"section"},{"location":"models/coupled_vanderpol/#References","page":"Coupled VanDerPol","title":"References","text":"","category":"section"},{"location":"models/fom/","page":"Fom","title":"Fom","text":"using ReachabilityModels, MAT, ReachabilityBase.CurrentPath\n\nfile = matopen(@current_path(\"fom\", \"fom.mat\"))\n\nsystem matrix\n\nA = float(read(file, \"A\"))  # the matrix has Int entries\n\ninput matrix\n\nB = read(file, \"B\")\n\nstate domain\n\nX = Universe(1006)\n\ninput domain\n\nU = BallInf([0.0], 1.0)\n\nfunction model(X0)\n    S = @system(x' = Ax + Bu, x ∈ X, u ∈ U)\n    return IVP(S, X0)\nend","category":"section"},{"location":"models/spiking_neuron/","page":"Spiking Neuron","title":"Spiking Neuron","text":"module spiking_neuron\nusing ReachabilityAnalysis, ModelingToolkit\n\n@taylorize function flow!(dx, x, params, t)\n    local a = 0.02\n    local b = 0.2\n    local I = 40\n    dx[1] = (0.04 * (x[1] * x[1]) + 5 * x[1]) + ((140 + I) - x[2])\n    dx[2] = a * ((b * x[1]) - x[2])\n    return dx\nend\n\nfunction spikingNeuron_model()\n    # hybrid automaton\n    HA = GraphAutomaton(1)\n\n    # mode 1\n    X = HPolyhedron([HalfSpace([1.0, 0.0], 30.0)])  # x1 ≤ 30\n    m1 = @system(x' = flow!(x), dim:2, x ∈ X)\n\n    # transition mode 1 → mode 1 (self loop)\n    add_transition!(HA, 1, 1, 1)\n    G = HPolyhedron([HalfSpace([-1.0, 0.0], -30.0)])  # x1 ≥ 30\n    A = [0.0 0.0; 0.0 1.0]\n    b = [-65.0, 8.0]\n    R11 = ConstrainedAffineMap(A, b, G)  # x1 := -65, x2 := x2 + 8\n\n    # hybrid system\n    S = HybridSystems.HybridSystem(HA, [m1], [R11], [AutonomousSwitching()])\n\n    return S\nend\n\nfunction model(X0)\n    H = spikingNeuron_model()\n    return IVP(H, X0)\nend\nend # module","category":"section"},{"location":"models/projectile/","page":"Projectile","title":"Projectile","text":"module projectile\nusing ReachabilityAnalysis, SparseArrays\n\n# system matrix\nA = sparse([1, 3], [2, 4], [0.5, 0.7], 4, 4)\n\n# affine term\nb = sparsevec([4], [-9.81], 4)\n\nfunction model(X0)\n    S = @system(x' = Ax + b)\n    return IVP(S, X0)\nend\nend # module","category":"section"},{"location":"models/thermostat/","page":"Thermostat","title":"Thermostat","text":"module thermostat\n\nusing ReachabilityAnalysis, ModelingToolkit\n\nconst A1 = 40.0\nconst A2 = 30.0\nconst B = 0.5\nconst t1 = 75\nconst t2 = 65\n\nconst var = @variables t\n\nfunction thermostat_on()\n    invariant = HalfSpace(t <= t1)\n    @system(x' = -Bx + A1, x ∈ invariant)\nend\n\nfunction thermostat_off()\n    invariant = HalfSpace(t >= t2)\n    @system(x' = -Bx + A2, x ∈ invariant)\nend\n\nfunction thermostat_hybrid()\n    automaton = GraphAutomaton(2)\n    add_transition!(automaton, 1, 2, 1)\n    add_transition!(automaton, 2, 1, 2)\n\n    mode1 = thermostat_on()\n    mode2 = thermostat_off()\n    modes = [mode1, mode2]\n\n    # transition on -> off\n    guard = HalfSpace(t >= t1)\n    trans1 = ConstrainedIdentityMap(1, guard)\n    # transition off -> on\n    guard = HalfSpace(t <= t2)\n    trans2 = ConstrainedIdentityMap(1, guard)\n    resetmaps = [trans1, trans2]\n\n    return HybridSystems.HybridSystem(automaton, modes, resetmaps, [AutonomousSwitching()])\nend\n\nfunction model(X0)\n    H = thermostat_hybrid()\n    return IVP(H, X0)\nend\n\nend  # module","category":"section"},{"location":"models/cardiac_cell/#Cardiac-cell","page":"Cardiac Cell","title":"Cardiac cell","text":"","category":"section"},{"location":"models/cardiac_cell/#Model","page":"Cardiac Cell","title":"Model","text":"using ReachabilityAnalysis, ModelingToolkit\n\nvars = @variables u, v, t\n\n@taylorize function cardiac_cell_on!(dx, x, params, t)\n    dx[1] = -0.9 * x[1]^2 - x[1]^3 - 0.9 * x[1] - x[2] + 1\n    dx[2] = x[1] - 2 * x[2]\n    dx[3] = one(x[3])\n    return dx\nend\n\n@taylorize function cardiac_cell_off!(dx, x, params, t)\n    dx[1] = -0.9 * x[1]^2 - x[1]^3 - 0.9 * x[1] - x[2]\n    dx[2] = x[1] - 2 * x[2]\n    dx[3] = one(x[3])\n    return dx\nend\n\nfunction cardiac_cell_hybrid()\n    n = 2 + 1 # variables + time\n\n    automaton = GraphAutomaton(2)\n    add_transition!(automaton, 1, 2, 1)\n    add_transition!(automaton, 2, 1, 2)\n\n    # mode 1 \"approaching\"\n    invariant = HalfSpace(t <= 5, vars)\n    mode1 = @system(x' = cardiac_cell_on!(x), dim:3, x ∈ invariant)\n    # mode 1 \"approaching\"\n    invariant = HalfSpace(t <= 20, vars)\n    mode2 = @system(x' = cardiac_cell_off!(x), dim:3, x ∈ invariant)\n    modes = [mode1, mode2]\n\n    reset = Dict(n => 0.0)\n\n    # transition on -> off\n    guard = HalfSpace(t >= 5)\n    trans1 = ConstrainedResetMap(n, guard, reset)\n    # transition off -> on\n    guard = HalfSpace(t >= 20)\n    trans2 = ConstrainedResetMap(n, guard, reset)\n    resetmaps = [trans1, trans2]\n\n    return HybridSystems.HybridSystem(automaton, modes, resetmaps, [AutonomousSwitching()])\nend\n\nfunction model(X0)\n    H = cardiac_cell_hybrid()\n    return IVP(H, X0)\nend","category":"section"},{"location":"models/cardiac_cell/#References","page":"Cardiac Cell","title":"References","text":"","category":"section"},{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/#Utility-functions","page":"Usage","title":"Utility functions","text":"","category":"section"},{"location":"models/iss/","page":"ISS","title":"ISS","text":"using ReachabilityModels, MAT, ReachabilityBase.CurrentPath\n\nfile = matopen(@current_path(\"iss\", \"iss.mat\"))\n\nsystem matrix\n\nA = read(file, \"A\")\n\ninput matrix\n\nB = read(file, \"B\")\n\nstate domain\n\nX = Universe(270)\n\ninput domain\n\nU = Hyperrectangle([0.05, 0.9, 0.95], [0.05, 0.1, 0.05])\n\nfunction model(X0)\n    S = @system(x' = Ax + Bu, x ∈ X, u ∈ U)\n    return IVP(S, X0)\nend","category":"section"},{"location":"models/lotka_volterra/","page":"Lotka-Volterra","title":"Lotka-Volterra","text":"module lotka_volterra\nusing ReachabilityAnalysis\n@taylorize function lotka_volterra!(du, u, p, t)\n    local α, β, γ, δ = 1.5, 1.0, 3.0, 1.0\n    du[1] = u[1] * (α - β * u[2])\n    du[2] = -u[2] * (γ - δ * u[1])\n    return du\nend\n\nfunction model(X0)\n    S = @system(x' = lotka_volterra!(x), dim:2)\n    return IVP(S, X0)\nend\nend # module","category":"section"},{"location":"models/spring_pendulum/","page":"Spring Pendulum","title":"Spring Pendulum","text":"module spring_pendulum\nusing ReachabilityAnalysis\n@taylorize function spring_pendulum!(du, u, p, t)\n    local g, k, L = 9.8, 2.0, 1.0\n    du[1] = u[3]\n    du[2] = u[4]\n    du[3] = ((u[1] * (u[4] * u[4])) + g * cos(u[2])) - k * (u[1] - L)\n    du[4] = -((2 * u[3] * u[4]) + g * sin(u[2])) / (u[1])\n\n    # change of variables: r <- r - L\n    #du[3] = (((u[1]+L) * (u[4]*u[4])) + g*cos(u[2])) - k*(u[1])\n    #du[4] = -((2*u[3]*u[4]) + g*sin(u[2]))/(u[1]+L)\n\n    return du\nend\n\nfunction model(X0)\n    S = @system(x' = spring_pendulum!(x), dim:4)\n    return IVP(S, X0)\nend\nend # module","category":"section"},{"location":"models/heat/#Heat","page":"Heat","title":"Heat","text":"","category":"section"},{"location":"models/heat/#Model","page":"Heat","title":"Model","text":"using ReachabilityModels, MAT, SparseArrays, ReachabilityBase.CurrentPath\n\nfile = matopen(@current_path(\"heat\", \"heat.mat\"))\n\n# system matrix\nA = read(file, \"A\")\n\n# input matrix\nB = sparse([67], [1], [1.0], size(A, 1), 1)\n\n# state domain\nX = Universe(200)\n\n# input domain\nU = BallInf([0.0], 0.5)\n\nfunction model(X0)\n    S = @system(x' = Ax + Bu, x ∈ X, u ∈ U)\n    return IVP(S, X0)\nend","category":"section"},{"location":"models/heat/#References","page":"Heat","title":"References","text":"","category":"section"},{"location":"models/roessler/","page":"Roessler","title":"Roessler","text":"module roessler\nusing ReachabilityAnalysis\n@taylorize function roessler!(du, u, p, t)\n    local a, b, c = 0.2, 0.2, 5.7\n\n    du[1] = -u[2] - u[3]\n    du[2] = u[1] + (a * u[2])\n    du[3] = b + (u[3] * (u[1] - c))\n\n    return du\nend\n\nfunction model(X0)\n    S = @system(x' = roessler!(x), dim:3)\n    return IVP(S, X0)\nend\nend # module","category":"section"},{"location":"models/bouncing_ball_nonlinear/#Nonlinear-bouncing-ball","page":"Nonlinear Bouncing ball","title":"Nonlinear bouncing ball","text":"","category":"section"},{"location":"models/bouncing_ball_nonlinear/#Model","page":"Nonlinear Bouncing ball","title":"Model","text":"using ReachabilityAnalysis, ModelingToolkit\n\n@taylorize function flow_down!(du, u, params, t)\n    du[1] = u[2]\n    du[2] = -9.8 + 0.1 * (u[2])^2\n    return du\nend\n\n@taylorize function flow_up!(du, u, params, t)\n    du[1] = u[2]\n    du[2] = -9.8 - 0.1 * (u[2])^2\n    return du\nend\n\nfunction bouncingBallNonlinear_model()\n    var = @variables x, v\n\n    # hybrid automaton with state variables x, v\n    HA = GraphAutomaton(2)\n\n    # mode 1 (\"down\")\n    X = HPolyhedron([x ≥ 0, v ≤ 0], vars)\n    m1 = @system(x' = flow_down!(x), dim:2, x ∈ X)\n\n    # mode 2 (\"up\")\n    X = HPolyhedron([x ≥ 0, v ≥ 0], vars)\n    m2 = @system(x' = flow_up!(x), dim:2, x ∈ X)\n\n    # α transition down → up\n    add_transition!(HA, 1, 2, 1)\n    G = HalfSpace(x ≤ 0, vars)\n    A = [1.0 0.0; 0.0 -0.8]\n    Rα = ConstrainedLinearMap(A, G)  # v := -0.8v\n\n    # β transition up → down\n    add_transition!(HA, 2, 1, 2)\n    G = HalfSpace(v ≤ 0, vars)\n    Rβ = ConstrainedIdentityMap(2, G)\n\n    # hybrid system\n    S = HybridSystems.HybridSystem(HA, [m1, m2], [Rα, Rβ], fill(AutonomousSwitching(), 2))\n\n    return S\nend\n\nfunction model(X0)\n    H = bouncingBallNonlinear_model()\n    return IVP(H, X0)\nend","category":"section"},{"location":"overview_hybrid/#Hybrid-models","page":"Overview","title":"Hybrid models","text":"The following models have hybrid dynamics.\n\nName State dimension\nautomatic_lane_change_system 6\nbouncing_ball 2\nbouncing_ball_nonlinear 2\ncardiac_cell 3\nclocked_thermostat 2\nfiltered_oscillator 3\nlinear_switching 1\nnavigation_system 4\npowertrain_control 5\nspiking_neuron 2\nthermostat 1\ntwo_tanks 2","category":"section"},{"location":"models/powertrain_control/","page":"Powertrain Control","title":"Powertrain Control","text":"module powertrain_control\nusing ReachabilityAnalysis, ModelingToolkit\n#using Polyhedra, CDDLib # ??\n\nvars = @variables p, lam, pe, i, t\n\n@taylorize function startup!(dx, x, params, t)\n    p, lam, pe, i = x\n    dx[1] = 0.41328 * (2 * 247 * (-2.3421 * p * p + 2.7799 * p - 0.3273) -\n                       0.9 * (-3.66 + 0.08979 * 104.71975511 * p - 0.0337 * 104.71975511 * p * p +\n                              0.0001 * 104.71975511 * 104.71975511 * p))\n    dx[2] = 4 * (13.893 -\n                 35.2518 * 1 *\n                 ((1 / 14.7) * (-3.66 + 0.08979 * 104.71975511 * pe - 0.0337 * 104.71975511 * pe * pe +\n                                0.0001 * pe * 104.71975511 * 104.71975511)) +\n                 20.7364 * 1 * 1 *\n                 ((1 / 14.7) * (-3.66 + 0.08979 * 104.71975511 * pe - 0.0337 * 104.71975511 * pe * pe +\n                                0.0001 * pe * 104.71975511 * 104.71975511)) *\n                 ((1 / 14.7) * (-3.66 + 0.08979 * 104.71975511 * pe - 0.0337 * 104.71975511 * pe * pe +\n                                0.0001 * pe * 104.71975511 * 104.71975511)) +\n                 2.6287 * (0.9 * (-3.66 + 0.08979 * 104.71975511 * p - 0.0337 * 104.71975511 * p * p +\n                                  0.0001 * p * 104.71975511 * 104.71975511)) -\n                 1.592 *\n                 (0.9 * (-3.66 + 0.08979 * 104.71975511 * p - 0.0337 * 104.71975511 * p * p +\n                         0.0001 * p * 104.71975511 * 104.71975511)) * 1 *\n                 ((1 / 14.7) * (-3.66 + 0.08979 * 104.71975511 * pe - 0.0337 * 104.71975511 * pe * pe +\n                                0.0001 * pe * 104.71975511 * 104.71975511)) - lam)\n    dx[3] = 0.41328 * (2 * 1 * (247) * (-2.3421 * p * p + 2.7799 * p - 0.3273) -\n                       (-3.66 + 0.08979 * 104.71975511 * pe - 0.0337 * 104.71975511 * pe * pe +\n                        0.0001 * pe * 104.71975511 * 104.71975511))\n    dx[4] = zero(i)\n    return dx\nend\n\n@taylorize function normal!(dx, x, params, t)\n    p, lam, pe, i = x\n    dx[1] = 0.41328 * (2 * 1 * (247) * (-2.3421 * p * p + 2.7799 * p - 0.3273) -\n                       (-3.66 + 0.08979 * 104.71975511 * pe - 0.0337 * 104.71975511 * pe * pe +\n                        0.0001 * pe * 104.71975511 * 104.71975511))\n    dx[2] = 4 * (13.893 -\n                 35.2518 * 1 *\n                 ((1 / 14.7) * (1 + ivalue + 0.04 * (1 * lam - 14.7)) *\n                  (-0.366 + 0.08979 * 104.71975511 * pe - 0.0337 * 104.71975511 * pe * pe +\n                   0.0001 * pe * 104.71975511 * 104.71975511)) +\n                 20.7364 * 1 * 1 *\n                 ((1 / 14.7) * (1 + ivalue + 0.04 * (1 * lam - 14.7)) *\n                  (-0.366 + 0.08979 * 104.71975511 * pe - 0.0337 * 104.71975511 * pe * pe +\n                   0.0001 * pe * 104.71975511 * 104.71975511)) *\n                 ((1 / 14.7) * (1 + ivalue + 0.04 * (1 * lam - 14.7)) *\n                  (-0.366 + 0.08979 * 104.71975511 * pe - 0.0337 * 104.71975511 * pe * pe +\n                   0.0001 * pe * 104.71975511 * 104.71975511)) +\n                 2.6287 * (0.9 * (-0.366 + 0.08979 * 104.71975511 * p - 0.0337 * 104.71975511 * p * p +\n                                  0.0001 * p * 104.71975511 * 104.71975511)) -\n                 1.592 *\n                 (0.9 * (-0.366 + 0.08979 * 104.71975511 * p - 0.0337 * 104.71975511 * p * p +\n                         0.0001 * p * 104.71975511 * 104.71975511)) * 1 *\n                 ((1 / 14.7) * (1 + ivalue + 0.04 * (1 * lam - 14.7)) *\n                  (-0.366 + 0.08979 * 104.71975511 * pe - 0.0337 * 104.71975511 * pe * pe +\n                   0.0001 * pe * 104.71975511 * 104.71975511)) - lam)\n    dx[3] = 0.41328 * (2 * 1 * (247.0) * (-2.3421 * p * p + 2.7799 * p - 0.3273) -\n                       (-0.366 + 0.08979 * 104.71975511 * pe - 0.0337 * 104.71975511 * pe * pe +\n                        0.0001 * pe * 104.71975511 * 104.71975511))\n    dx[4] = 0.14 * (1 * lam - 14.7)\n    return dx\nend\n\nfunction powertrain_control_hybrid()\n    n = 4 + 1 # variables\n\n    automaton = GraphAutomaton(2)\n    add_transition!(automaton, 1, 2, 1)\n\n    # mode 1 \"startup\"\n    invariant = HPolyhedron([HalfSpace(t >= 9.5, vars), HalfSpace(t <= 20, vars)])\n    mode1 = @system(x' = startup!(x), dim:5, x ∈ invariant)\n    # mode 1 \"normal\"\n    invariant = Universe(n)\n    mode2 = @system(x' = normal!(x), dim:5, x ∈ invariant)\n    modes = [mode1, mode2]\n\n    reset = Dict(n => 0.0)\n\n    # transition startup -> normal\n    guard = HalfSpace(t >= 9.5, vars)\n    trans1 = ConstrainedResetMap(n, guard, reset)\n    resetmaps = [trans1]\n\n    return HybridSystems.HybridSystem(automaton, modes, resetmaps, [AutonomousSwitching()])\nend\n\nfunction model(X0)\n    H = powertrain_control_hybrid()\n    return IVP(H, [(1, X0)])\nend\nend # module","category":"section"},{"location":"models/mna5/","page":"MNA5","title":"MNA5","text":"using ReachabilityModels, MAT, SparseArrays, ReachabilityBase.CurrentPath\n\nfile = matopen(@current_path(\"mna5\", \"mna5.mat\"))\n\nsystem matrix\n\nA = sparse(read(file, \"A\"))\n\naffine term\n\nb = sparsevec(19:27, [fill(-0.1, 5); fill(-0.2, 4)], 10913)\n\nfunction model(X0)\n    S = @system(x' = Ax + b)\n    return IVP(S, X0)\nend","category":"section"},{"location":"models/mna1/","page":"MNA1","title":"MNA1","text":"using ReachabilityModels, MAT, SparseArrays, ReachabilityBase.CurrentPath\n\nfile = matopen(@current_path(\"mna1\", \"mna1.mat\"))\n\nsystem matrix\n\nA = sparse(read(file, \"A\"))\n\naffine term\n\nb = sparsevec(570:578, [fill(-0.1, 5); fill(-0.2, 4)], 578)\n\nfunction model(X0)\n    S = @system(x' = Ax + b)\n    return IVP(S, X0)\nend","category":"section"},{"location":"overview_nonlinear/#Nonlinear-models","page":"Overview","title":"Nonlinear models","text":"The following models have nonlinear dynamics.\n\nName State dimension\nautomatic_lane_change_system 6\nbiomodel7d 7\nbiomodel9d 9\nbouncing_ball_nonlinear 2\nbrusselator 2\nbuckling_column 2\ncardiac_cell 3\ncoupled_vanderpol 4\ndoublegyre 2\nhenon_heiles 4\njet_engine 2\nlorenz 3\nlotka_volterra 2\npowertrain_control 5\nrobot_arm 2\nroessler 3\nspiking_neuron 2\nspring_pendulum 4\nsteam_governor 3\nvanderpol 2","category":"section"},{"location":"models/beam/#Beam","page":"Beam","title":"Beam","text":"","category":"section"},{"location":"models/beam/#Model","page":"Beam","title":"Model","text":"using ReachabilityModels, MAT, ReachabilityBase.CurrentPath\n\nfile = matopen(@current_path(\"beam\", \"beam.mat\"))\n\n# system matrix\nA = read(file, \"A\")\n\n# input matrix\nB = read(file, \"B\")\n\n# state domain\nX = Universe(348)\n\n# input domain\nU = BallInf([0.9], 0.1)\n\nfunction model(X0)\n    S = @system(x' = Ax + Bu, x ∈ X, u ∈ U)\n    return IVP(S, X0)\nend","category":"section"},{"location":"models/beam/#References","page":"Beam","title":"References","text":"","category":"section"},{"location":"models/vanderpol/","page":"VanDerPol","title":"VanDerPol","text":"module vanderpol\nusing ReachabilityAnalysis\n@taylorize function vanderpol!(dx, x, params, t)\n    local μ = 1.0\n    dx[1] = x[2]\n    dx[2] = (μ * x[2]) * (1 - x[1]^2) - x[1]\n    return dx\nend\n\nfunction model(X0)\n    S = @system(x' = vanderpol!(x), dim:2)\n    return IVP(S, X0)\nend\nend # module","category":"section"},{"location":"models/steam_governor/","page":"Steam Governor","title":"Steam Governor","text":"module steam_governor\nusing ReachabilityAnalysis\n@taylorize function steam_governor!(du, u, p, t)\n    local ϵ = 3.0\n    local α = 1.0\n    local β = 1.0\n\n    du[1] = u[2]\n    du[2] = u[3]^2 * sin(u[1]) * cos(u[1]) - sin(u[1]) - ϵ * u[2]\n    du[3] = α * (cos(u[1]) - β)\n\n    return du\nend\n\nfunction model(X0)\n    S = @system(x' = steam_governor!(x), dim:3)\n    return IVP(S, X0)\nend\nend # module","category":"section"},{"location":"models/biomodel7d/#BioModel7d","page":"Biomodel 7d","title":"BioModel7d","text":"","category":"section"},{"location":"models/biomodel7d/#Model","page":"Biomodel 7d","title":"Model","text":"using ReachabilityAnalysis\n\n@taylorize function biomodel7d!(dx, x, p, t)\n    dx[1] = -0.4 * x[1] + 5.0 * x[3] * x[4]\n    dx[2] = 0.4 * x[1] - x[2]\n    dx[3] = x[2] - 5.0 * x[3] * x[4]\n    dx[4] = 5.0 * x[5] * x[6] - 5.0 * x[3] * x[4]\n    dx[5] = -5.0 * x[5] * x[6] + 5.0 * x[3] * x[4]\n    dx[6] = 0.5 * x[7] - 5.0 * x[5] * x[6]\n    dx[7] = -0.5 * x[7] + 5.0 * x[5] * x[6]\n    return dx\nend\n\nfunction model(X0)\n    S = @system(x' = biomodel7d!(x), dim:7)\n    return IVP(S, X0)\nend","category":"section"},{"location":"models/biomodel7d/#References","page":"Biomodel 7d","title":"References","text":"","category":"section"},{"location":"models/doublegyre/#Double-Gyre","page":"Double Gyre","title":"Double Gyre","text":"","category":"section"},{"location":"models/doublegyre/#Model","page":"Double Gyre","title":"Model","text":"using ReachabilityAnalysis\n\n@taylorize function doublegyre!(dx, x, params, t)\n    local A = 0.1\n    dx[1] = -π * A * sin(π * x[1]) * cos(π * x[2])\n    dx[2] = π * A * cos(π * x[1]) * sin(π * x[2])\n    return dx\nend\n\nfunction model(X0)\n    S = @system(x' = doublegyre!(x), dim:2)\n    return IVP(S, X0)\nend","category":"section"},{"location":"models/doublegyre/#References","page":"Double Gyre","title":"References","text":"","category":"section"},{"location":"models/bouncing_ball/#Bouncing-ball","page":"Bouncing ball","title":"Bouncing ball","text":"","category":"section"},{"location":"models/bouncing_ball/#Model","page":"Bouncing ball","title":"Model","text":"We model the bouncing ball as a hybrid automaton with one location and a self-loop. See for example [LG09] pp. 79-83.\n\nusing ReachabilityAnalysis, ModelingToolkit\n\nfunction _bouncing_ball()\n    var = @variables x v\n\n    # \"falling\" mode with invariant x >= 0\n    invariant = HalfSpace(x ≥ 0, var)\n    flow = @system(z' = [0.0 1.0; 0.0 0.0] * z + [0.0, -9.81], z ∈ invariant)\n\n    # guard x == 0 && v ≤ 0\n    guard = HPolyhedron([0 ≤ x, x ≤ 0, v ≤ 0], var)\n\n    # reset map v⁺ := -cv\n    assignment = ConstrainedLinearMap([1.0 0.0; 0.0 -0.75], guard)\n\n    # initial-value problem\n    return HybridSystem(flow, assignment)\nend\n\nfunction model(X0)\n    H = _bouncing_ball()\n    return @ivp(H, z(0) ∈ X0)\nend","category":"section"},{"location":"models/bouncing_ball/#References","page":"Bouncing ball","title":"References","text":"[LG09]: Le Guernic, Colas. Reachability analysis of hybrid systems with linear continuous dynamics. Diss. 2009.","category":"section"},{"location":"models/building/#Building","page":"Building","title":"Building","text":"","category":"section"},{"location":"models/building/#Model","page":"Building","title":"Model","text":"using ReachabilityModels, MAT, ReachabilityBase.CurrentPath\n\nfile = matopen(@current_path(\"building\", \"building.mat\"))\n\n# system matrix\nA = read(file, \"A\")\n\n# input matrix\nB = read(file, \"B\")\n\n# state domain\nX = Universe(48)\n\n# input domain\nU = BallInf([0.5], 0.3)\n\nfunction model(X0)\n    S = @system(x' = Ax + Bu, x ∈ X, u ∈ U)\n    return IVP(S, X0)\nend","category":"section"},{"location":"models/building/#References","page":"Building","title":"References","text":"","category":"section"},{"location":"#ReachabilityModels.jl","page":"Home","title":"ReachabilityModels.jl","text":"","category":"section"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"overview_linear/#Linear-models","page":"Overview","title":"Linear models","text":"The following models have linear dynamics.\n\nName State dimension\nbeam 348\nbouncing_ball 2\nbuilding 48\ncdplayer 120\nclocked_thermostat 2\ncrane 6\nellipse 2\nfiltered_oscillator 3\nfive_dim_sys 5\nfom 1006\nheat 200\nhelicopter 28\niss 270\nlinear_switching 1\nmna1 578\nmna5 10913\nmotor 8\nnavigation_system 4\npde 84\nprojectile 4\nthermostat 1\ntwo_tanks 2\nvehicle_platoon_10 30\nvehicle_platoon_5 15","category":"section"},{"location":"about/#About","page":"About","title":"About","text":"","category":"section"},{"location":"models/robot_arm/","page":"Robot Arm","title":"Robot Arm","text":"module robot_arm\nusing ReachabilityAnalysis\n@taylorize function robot_arm!(dx, x, params, t)\n    dx[1] = x[3]\n    dx[2] = x[4]\n    dx[3] = (-2x[2] * x[3] * x[4] - 2x[1] - 2x[3] + 4) / (x[2]^2 + 1)\n    dx[4] = x[2] * x[3]^2 - x[2] - x[4] + 1\n    return dx\nend\n\nfunction model(X0)\n    S = @system(x' = robot_arm!(x), dim:4)\n    return IVP(S, X0)\nend\nend # module","category":"section"},{"location":"models/buckling_column/#Buckling-column","page":"Bucking column","title":"Buckling column","text":"","category":"section"},{"location":"models/buckling_column/#Model","page":"Bucking column","title":"Model","text":"using ReachabilityAnalysis\n\n@taylorize function buckling_column!(dx, x, params, t)\n    dx[1] = x[2]\n    dx[2] = 2 * x[1] - x[1]^3 - 0.2 * x[2] + 0.1\n    return dx\nend","category":"section"},{"location":"models/buckling_column/#References","page":"Bucking column","title":"References","text":"","category":"section"},{"location":"models/five_dim_sys/#Five-dim-sys","page":"Five Dim System","title":"Five dim sys","text":"","category":"section"},{"location":"models/five_dim_sys/#Model","page":"Five Dim System","title":"Model","text":"using ReachabilityAnalysis\n\n# system matrix\nD = [-1.0 -4.0 0.0 0.0 0.0;\n     4.0 -1.0 0.0 0.0 0.0;\n     0.0 0.0 -3.0 1.0 0.0;\n     0.0 0.0 -1.0 -3.0 0.0;\n     0.0 0.0 0.0 0.0 -2.0]\nP = [0.6 -0.1 0.1 0.7 -0.2;\n     -0.5 0.7 -0.1 -0.8 0.0;\n     0.9 -0.5 0.3 -0.6 0.1;\n     0.5 -0.7 0.5 0.6 0.3;\n     0.8 0.7 0.6 -0.3 0.2]\nA = P * D * inv(P)\n\n# state domain\nX = Universe(5)\n\n# input domain\nU = Ball2(zeros(5), 0.01)\n\nfunction model(X0)\n    S = @system(x' = Ax + u, x ∈ X, u ∈ U)\n    return IVP(S, X0)\nend","category":"section"},{"location":"models/five_dim_sys/#References","page":"Five Dim System","title":"References","text":"","category":"section"},{"location":"models/cdplayer/#CDPlayer","page":"CD Player","title":"CDPlayer","text":"","category":"section"},{"location":"models/cdplayer/#Model","page":"CD Player","title":"Model","text":"using ReachabilityModels, MAT, ReachabilityBase.CurrentPath\n\nfile = matopen(@current_path(\"cdplayer\", \"cdplayer.mat\"))\n\n# system matrix\nA = read(file, \"A\")\n\n# input matrix\nB = read(file, \"B\")\n\n# state domain\nX = Universe(120)\n\n# input domain\nU = BallInf([0.0, 0.0], 1.0)\n\nfunction model(X0)\n    S = @system(x' = Ax + Bu, x ∈ X, u ∈ U)\n    return IVP(S, X0)\nend","category":"section"},{"location":"models/cdplayer/#References","page":"CD Player","title":"References","text":"","category":"section"},{"location":"models/biomodel9d/#BioModel9d","page":"Biomodel 9d","title":"BioModel9d","text":"","category":"section"},{"location":"models/biomodel9d/#Model","page":"Biomodel 9d","title":"Model","text":"using ReachabilityAnalysis\n\n@taylorize function biomodel9d!(dx, x, p, t)\n    dx[1] = 3.0 * x[3] - x[1] * x[6]\n    dx[2] = x[4] - x[2] * x[6]\n    dx[3] = x[1] * x[6] - 3.0 * x[3]\n    dx[4] = x[2] * x[6] - x[4]\n    dx[5] = 3.0 * x[3] + 5.0 * x[1] - x[5]\n    dx[6] = 5.0 * x[5] + 3.0 * x[3] + x[4] - x[6] * (x[1] + x[2] + 2.0 * x[8] + 1.0)\n    dx[7] = 5.0 * x[4] + x[2] - 0.5 * x[7]\n    dx[8] = 5.0 * x[7] - 2.0 * x[6] * x[8] + x[9] - 0.2 * x[8]\n    dx[9] = 2.0 * x[6] * x[8] - x[9]\n    return dx\nend\n\nfunction model(X0)\n    S = @system(x' = biomodel9d!(x), dim:9)\n    return IVP(S, X0)\nend","category":"section"},{"location":"models/biomodel9d/#References","page":"Biomodel 9d","title":"References","text":"","category":"section"},{"location":"models/henon_heiles/","page":"Henon-Helies","title":"Henon-Helies","text":"module henon_heiles\nusing ReachabilityAnalysis\n@taylorize function henon_heiles!(du, u, p, t)\n    p₁, p₂, q₁, q₂ = u[1], u[2], u[3], u[4]\n    du[1] = -q₁ * (1 + 2q₂)\n    du[2] = -q₂ - (q₁^2 - q₂^2)\n    du[3] = p₁\n    return du[4] = p₂\nend\n\nfunction model(X0)\n    S = @system(x' = henon_heiles!(x), dim:4)\n    return IVP(S, X0)\nend\nend # module","category":"section"},{"location":"models/clocked_thermostat/#Clocked-thermostat","page":"Clocked Thermostat","title":"Clocked thermostat","text":"","category":"section"},{"location":"models/clocked_thermostat/#Model","page":"Clocked Thermostat","title":"Model","text":"using ReachabilityAnalysis, ModelingToolkit\n\nconst A1 = 40.0\nconst A2 = 30.0\nconst B = 0.5\nconst t1 = 75\nconst t2 = 65\n\nconst var′ = @variables t t′\n\nfunction thermostat_on′()\n    invariant = HalfSpace(t <= t1, var′)\n    @system(x' = [-B 0; 0 0] * x + [A1, 1], x ∈ invariant)\nend\n\nfunction thermostat_off′()\n    invariant = HalfSpace(t >= t2, var′)\n    @system(x' = [-B 0; 0 0] * x + [A2, 1], x ∈ invariant)\nend\n\nfunction thermostat_hybrid′()\n    automaton = GraphAutomaton(2)\n    add_transition!(automaton, 1, 2, 1)\n    add_transition!(automaton, 2, 1, 2)\n\n    mode1 = thermostat_on′()\n    mode2 = thermostat_off′()\n    modes = [mode1, mode2]\n\n    # transition on -> off\n    guard = HalfSpace(t >= t1, var′)\n    trans1 = ConstrainedIdentityMap(1, guard)\n    # transition off -> on\n    guard = HalfSpace(t <= t2, var′)\n    trans2 = ConstrainedIdentityMap(1, guard)\n    resetmaps = [trans1, trans2]\n\n    return HybridSystems.HybridSystem(automaton, modes, resetmaps, [AutonomousSwitching()])\nend\n\nfunction model(X0)\n    H = thermostat_hybrid′()\n    return IVP(H, X0)\nend","category":"section"},{"location":"models/clocked_thermostat/#References","page":"Clocked Thermostat","title":"References","text":"","category":"section"},{"location":"models/crane/#Crane","page":"Crane","title":"Crane","text":"","category":"section"},{"location":"models/crane/#Model","page":"Crane","title":"Model","text":"using ReachabilityAnalysis\n\nA = [0.0 1.0 0.0 0.0 0.0 0.0;\n     -0.417533 -3.1931759963 39.24 0.0 -14.825331 11.123344;\n     0.0 0.0 0.0 1.0 0.0 0.0;\n     0.0417533 0.31931759963 -4.905 0.0 1.4825331 -1.1123344;\n     0.0638407957 -0.32473339016573 0.0 0.0 -3.7332068901 -0.7007592976;\n     0.0853437452 -0.72366802635628 0.0 0.0 -5.9714023436 -2.2736115136]\n\nfunction model(X0)\n    S = @system(x' = Ax)\n    return IVP(S, X0)\nend","category":"section"},{"location":"models/crane/#References","page":"Crane","title":"References","text":"","category":"section"},{"location":"models/helicopter/#Helicopter","page":"Helicopter","title":"Helicopter","text":"note: Overview\nSystem type: linear continuous system\nState dimension: 28\nApplication domain:\n\nThis is a 28-dimensional controlled helicopter model.\n\nusing ReachabilityModels, MAT, ReachabilityBase.CurrentPath\n\nfile = matopen(@current_path(\"helicopter\", \"sx/heli.mat\"))\n\nsystem matrix\n\nA = read(file, \"A\")\n\ninput matrix\n\nB = read(file, \"B\")\n\nstate domain\n\nX = Universe(28)\n\ninput domain\n\nU = Hyperrectangle(zeros(6), [0, 0, 0, 0.001, 0.001, 0.001])\n\nfunction model(X0)\n    S = @system(x' = A * x + B * u, x ∈ X, u ∈ U)\n    return IVP(S, X0)\nend","category":"section"},{"location":"models/motor/","page":"Motor","title":"Motor","text":"using ReachabilityModels, SparseArrays\n\nsystem matrix\n\nI = [1, 2, 2, 3, 3, 3, 3, 4, 5, 6, 6, 7, 7, 7, 7, 8]\nJ = [2, 3, 2, 1, 2, 3, 4, 1, 6, 7, 6, 5, 6, 7, 8, 5]\nV = [1, 8487.2, -1.0865, -2592.1, -21.119, -698.91, -141399.0, 1.0, 1.0,\n     8487.2, -1.0865, -2592.1, -21.119, -698.91, -141399.0, 1.0]\nA = sparse(I, J, V)\n\ninput matrix\n\nB = sparse([4, 8], [1, 2], [-1.0, -1.0])\n\nstate domain\n\nX = Universe(8)\n\ninput domain\n\nU = Hyperrectangle([0.23, 0.3], [0.07, 0.1])\n\nfunction model(X0)\n    S = @system(x' = Ax + Bu, x ∈ X, u ∈ U)\n    return IVP(S, X0)\nend","category":"section"},{"location":"overview_total/#Model-overview","page":"Overview","title":"Model overview","text":"The following table shows the number of models for each type of system.\n\nLinear Nonlinear Hybrid Total\n24 20 12 56","category":"section"},{"location":"models/ellipse/#Ellipse","page":"Ellipse","title":"Ellipse","text":"","category":"section"},{"location":"models/ellipse/#Model","page":"Ellipse","title":"Model","text":"using ReachabilityAnalysis\n\nA = [3.0 -9.0;\n     4.0 -3.0]\n\nfunction model(X0)\n    S = @system(x' = Ax)\n    return IVP(S, X0)\nend","category":"section"},{"location":"models/ellipse/#References","page":"Ellipse","title":"References","text":"","category":"section"},{"location":"models/navigation_system/","page":"Navigation System","title":"Navigation System","text":"module navigation_system\n\nusing ReachabilityAnalysis, ModelingToolkit\n\nconst var = @variables x, y, v_x, v_y\n\nfunction mode0()\n    A = [0 0 1 0;\n         0 0 0 1;\n         0 0 -1.2 0.1;\n         0 0 0.1 -1.2]\n    B = [0, 0, -0.1, 1.2]\n    invariant = UnionSetArray([HalfSpace(x <= 1),\n                               HalfSpace(v_x <= 0),\n                               HalfSpace(y <= 1),\n                               HalfSpace(v_y <= 0)])\n    return @system(x' = Ax + B, x ∈ invariant)\nend\n\nfunction mode1()\n    A = [0 0 1 0;\n         0 0 0 1;\n         0 0 -1.2 0.1;\n         0 0 0.1 -1.2]\n    B = [0, 0, -4.8, 0.4]\n    invariant = UnionSetArray([HalfSpace(x >= 1),\n                               HalfSpace(v_x <= 0),\n                               HalfSpace(y <= 1),\n                               HalfSpace(v_y <= 0)])\n    return @system(x' = Ax + B, x ∈ invariant)\nend\n\nfunction mode2()\n    A = [0 0 1 0;\n         0 0 0 1;\n         0 0 -1.2 0.1;\n         0 0 0.1 -1.2]\n    B = [0, 0, 2.4, -0.2]\n    invariant = UnionSetArray([HalfSpace(x <= 1),\n                               HalfSpace(v_x <= 0),\n                               HalfSpace(y >= 1),\n                               HalfSpace(v_y >= 0)])\n    @system(x' = Ax + B, x ∈ invariant)\nend\n\nfunction mode3()\n    A = [0 0 1 0;\n         0 0 0 1;\n         0 0 -1.2 0.1;\n         0 0 0.1 -1.2]\n    B = [0, 0, 3.9, -3.9]\n    invariant = UnionSetArray([HalfSpace(x >= 1),\n                               HalfSpace(v_x >= 0),\n                               HalfSpace(y >= 1),\n                               HalfSpace(v_y >= 0)])\n    @system(x' = Ax + B, x ∈ invariant)\nend\n\nfunction navigation_system_hybrid()\n    automaton = GraphAutomaton(4)\n    add_transition!(automaton, 1, 2, 1)\n    add_transition!(automaton, 2, 1, 2)\n    add_transition!(automaton, 2, 4, 3)\n    add_transition!(automaton, 4, 2, 4)\n    add_transition!(automaton, 1, 3, 5)\n    add_transition!(automaton, 3, 1, 6)\n    add_transition!(automaton, 3, 4, 7)\n    add_transition!(automaton, 4, 3, 8)\n\n    modes = [mode0(), mode1(), mode2(), mode3()]\n\n    # transition 1 -> 2\n    guard = HPolyhedron([HalfSpace(x >= 1), HalfSpace(v_x >= 0)])\n    trans1 = ConstrainedIdentityMap(4, guard)\n    # transition 2 -> 1\n    guard = HPolyhedron([HalfSpace(x <= 1), HalfSpace(v_x <= 0)])\n    trans2 = ConstrainedIdentityMap(4, guard)\n    # transition 2 -> 4\n    guard = HPolyhedron([HalfSpace(y >= 1), HalfSpace(v_y >= 0)])\n    trans3 = ConstrainedIdentityMap(4, guard)\n    # transition 4 -> 2\n    guard = HPolyhedron([HalfSpace(y <= 1), HalfSpace(v_y <= 0)])\n    trans4 = ConstrainedIdentityMap(4, guard)\n    # transition 1 -> 3\n    guard = HPolyhedron([HalfSpace(y >= 1), HalfSpace(v_y >= 0)])\n    trans5 = ConstrainedIdentityMap(4, guard)\n    # transition 3 -> 1\n    guard = HPolyhedron([HalfSpace(y <= 1), HalfSpace(v_y <= 0)])\n    trans6 = ConstrainedIdentityMap(4, guard)\n    # transition 3 -> 4\n    guard = HPolyhedron([HalfSpace(x >= 1), HalfSpace(v_x >= 0)])\n    trans7 = ConstrainedIdentityMap(4, guard)\n    # transition 4 -> 3\n    guard = HPolyhedron([HalfSpace(x <= 1), HalfSpace(v_x <= 0)])\n    trans8 = ConstrainedIdentityMap(4, guard)\n    resetmaps = [trans1, trans2, trans3, trans4, trans5, trans6, trans7, trans8]\n\n    return HybridSystems.HybridSystem(automaton, modes, resetmaps, [AutonomousSwitching()])\nend\n\nfunction model(X0)\n    H = navigation_system_hybrid()\n    return IVP(H, [(1, X0)])\nend\n\nend  # module","category":"section"}]
}
